/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export type JsConsumer = Consumer
export class Consumer {
  constructor()
  /**
  * Reads from the commitlog for a set amount of time and returns a vector is messages when complete.
  * The offset where the starting read takes place is based off of the consumer group offset
  */
  poll(timeout: bigint): Array<JsMessage>
  /**
  * Given a starting offset and a max_records to return, fetch will read all of the offsets and return the records until there is no more records
  * or the max records limit has been hit.
  */
  fetch(startingOffset: number, maxRecords: number): Array<JsMessage>
  /**
  * Returns the topic that the consumer is consuming from.
  */
  getTopic(): string
  getOldestOffset(): bigint
  getLatestOffset(): bigint
}
export type JsLucidMQ = LucidMQ
export class LucidMQ {
  constructor(directory: string, maxSegmentSizeBytes: bigint, maxTopicSizeBytes: bigint)
  newProducer(topic: string): JsProducer
  newConsumer(topic: string, consumerGroupName: string): Consumer
}
export type JsMessage = Message
export class Message {
  constructor(key: Buffer, value: Buffer, timestamp?: number | undefined | null)
  serializeMessage(): Buffer
  static deserializeMessage(messageBytes: Buffer): Message
  getKey(): Buffer
  getValue(): Buffer
  getTimestamp(): number
}
export type JsProducer = Producer
export class Producer {
  constructor()
  produceMessage(message: Message): void
  getTopic(): string
}
